name: "Prepare Claude Context"
description: "Gate and classify events for Claude runs. For issue-based implement, pre-create Claude's target branch (no PR creation)."

inputs:
  mode:
    description: "review or implement"
    required: true

  # review 側の「implement 実行中ガード」で使う
  impl_workflow_id:
    description: "Workflow file name or ID for Claude Implement (e.g. Claude.yml)"
    required: true

  # pr-sync review 用（pull_requestイベントにのみ適用）
  skip_commit_prefixes:
    description: "Comma-separated prefixes to skip pr-sync review (e.g. docs:,style:,chore:,wip:)"
    required: false
    default: "docs:,style:,chore:,wip:"
  allow_final_sync_during_impl:
    description: "Allow pull_request synchronize review during implement (heuristics)."
    required: false
    default: "true"
  final_sync_commit_marker:
    description: "If non-empty, allow synchronize during implement when HEAD commit message contains this marker."
    required: false
    default: ""

  allowed_comment_permissions:
    description: "Comma-separated allowed permission levels for comment triggers"
    required: false
    default: "admin,maintain,write"
  max_workflow_runs_to_scan:
    description: "Max workflow runs to scan when checking implement running"
    required: false
    default: "50"

  # Issue implement 用（A: Claudeの枝名規則に合わせて事前に枝を作る）
  issue_branch_prefix:
    description: "Branch prefix for issue-based work (e.g. claude/issue-)"
    required: false
    default: "claude/issue-"
  # compare の base に使うブランチ名（Claude 側が master を使っているログがあるためデフォルト master）
  compare_base_branch:
    description: "Base branch name used in compare (e.g. master/main)"
    required: false
    default: "master"

outputs:
  should_run:
    description: "true if the workflow should proceed"
    value: ${{ steps.ctx.outputs.should_run }}
  reason:
    description: "reason for skip (debug)"
    value: ${{ steps.ctx.outputs.reason }}
  trigger_kind:
    value: ${{ steps.ctx.outputs.trigger_kind }}

  issue_number:
    description: "Issue number"
    value: ${{ steps.ctx.outputs.issue_number }}
  issue_url:
    description: "Issue URL"
    value: ${{ steps.ctx.outputs.issue_url }}

  pr_number:
    description: "PR number (only when PR context is resolved)"
    value: ${{ steps.ctx.outputs.pr_number }}
  head_sha:
    description: "Head sha (PR head or created branch base sha)"
    value: ${{ steps.ctx.outputs.head_sha }}
  head_ref:
    description: "Head ref (branch). For issue-based implement, this will be the pre-created Claude branch."
    value: ${{ steps.ctx.outputs.head_ref }}

  comment_body:
    description: "comment body if issue_comment, otherwise empty"
    value: ${{ steps.ctx.outputs.comment_body }}

runs:
  using: "composite"
  steps:
    - id: ctx
      uses: actions/github-script@v7
      env:
        MODE: ${{ inputs.mode }}
        IMPL_WORKFLOW_ID: ${{ inputs.impl_workflow_id }}

        SKIP_COMMIT_PREFIXES: ${{ inputs.skip_commit_prefixes }}
        ALLOW_FINAL_SYNC_DURING_IMPL: ${{ inputs.allow_final_sync_during_impl }}
        FINAL_SYNC_COMMIT_MARKER: ${{ inputs.final_sync_commit_marker }}

        ALLOWED_COMMENT_PERMISSIONS: ${{ inputs.allowed_comment_permissions }}
        MAX_WORKFLOW_RUNS_TO_SCAN: ${{ inputs.max_workflow_runs_to_scan }}

        ISSUE_BRANCH_PREFIX: ${{ inputs.issue_branch_prefix }}
        COMPARE_BASE_BRANCH: ${{ inputs.compare_base_branch }}
      with:
        script: |
          // Composite inputs are passed via env. (core.getInput reads github-script's inputs.)
          const modeRaw = process.env.MODE;
          const mode = String(modeRaw || '').trim().toLowerCase();
          core.info(`modeRaw=${JSON.stringify(modeRaw)} mode=${mode}`);

          const implWorkflowId = String(process.env.IMPL_WORKFLOW_ID || '').trim();

          const skipPrefixes = String(process.env.SKIP_COMMIT_PREFIXES || '')
            .split(',')
            .map(s => s.trim().toLowerCase())
            .filter(Boolean);

          const allowFinalSync = String(process.env.ALLOW_FINAL_SYNC_DURING_IMPL || 'true').toLowerCase() === 'true';
          const finalMarker = String(process.env.FINAL_SYNC_COMMIT_MARKER || '');

          const allowedPerms = new Set(
            String(process.env.ALLOWED_COMMENT_PERMISSIONS || 'admin,maintain,write')
              .split(',')
              .map(s => s.trim().toLowerCase())
              .filter(Boolean)
          );

          const maxRuns = Math.min(Math.max(Number(process.env.MAX_WORKFLOW_RUNS_TO_SCAN || '50'), 1), 100);

          const issueBranchPrefix = String(process.env.ISSUE_BRANCH_PREFIX || 'claude/issue-');
          const compareBaseBranch = String(process.env.COMPARE_BASE_BRANCH || 'master');

          function setOut(obj) {
            core.setOutput('should_run', obj.should_run ? 'true' : 'false');
            core.setOutput('reason', obj.reason || '');
            core.setOutput('trigger_kind', obj.trigger_kind || 'none');

            core.setOutput('issue_number', obj.issue_number ? String(obj.issue_number) : '');
            core.setOutput('issue_url', obj.issue_url || '');

            core.setOutput('pr_number', obj.pr_number ? String(obj.pr_number) : '');
            core.setOutput('head_sha', obj.head_sha || '');
            core.setOutput('head_ref', obj.head_ref || '');

            core.setOutput('comment_body', obj.comment_body || '');
          }
          const skip = (reason, extra = {}) => setOut({ should_run: false, reason, ...extra });
          const ok = (extra = {}) => setOut({ should_run: true, reason: '', ...extra });

          async function isImplementRunning({ prNumber, headRef, headSha }) {
            if (!implWorkflowId) return false;
            try {
              const runsResp = await github.rest.actions.listWorkflowRunsForWorkflow({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: implWorkflowId,
                per_page: maxRuns,
              });
              const runs = runsResp.data?.workflow_runs || [];
              const key = prNumber ? `pr #${prNumber}`.toLowerCase() : '';

              return runs.some(r => {
                if (!['queued', 'in_progress'].includes(r.status)) return false;

                const prs = r.pull_requests || [];
                if (prNumber && prs.some(p => String(p.number) === String(prNumber))) return true;

                const title = String(r.display_title || '').toLowerCase();
                if (key && title.includes(key)) return true;

                if (headRef && String(r.head_branch || '') === String(headRef)) return true;
                if (headSha && String(r.head_sha || '') === String(headSha)) return true;

                return false;
              });
            } catch (e) {
              core.info(`implement-running check failed (ignored): ${e.message}`);
              return false;
            }
          }

          function formatUtcYmdHm(isoString) {
            // isoString: "2026-02-03T07:54:12Z" -> "20260203-0754"
            const d = isoString ? new Date(isoString) : new Date();
            const y = d.getUTCFullYear();
            const m = String(d.getUTCMonth() + 1).padStart(2, '0');
            const day = String(d.getUTCDate()).padStart(2, '0');
            const hh = String(d.getUTCHours()).padStart(2, '0');
            const mm = String(d.getUTCMinutes()).padStart(2, '0');
            return `${y}${m}${day}-${hh}${mm}`;
          }

          async function ensureBranchExistsFromBase({ branchName, baseBranch }) {
            // baseBranch のHEAD sha を取得して branchName を作る（存在してたらOK）
            let baseSha = '';
            try {
              const refResp = await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `heads/${baseBranch}`,
              });
              baseSha = String(refResp.data?.object?.sha || '');
            } catch (e) {
              throw new Error(`failed-get-base-ref:${baseBranch}:${e.message}`);
            }
            if (!baseSha) throw new Error(`failed-resolve-base-sha:${baseBranch}`);

            try {
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/heads/${branchName}`,
                sha: baseSha,
              });
              core.info(`Created branch refs/heads/${branchName} from ${baseBranch}@${baseSha}`);
            } catch (e) {
              // already exists => 422
              core.info(`Branch create skipped (maybe exists): ${e.message}`);
            }
            return baseSha;
          }

          const ev = context.eventName;

          // ---- pull_request (review only) ※review workflow でも使う場合のために残す
          if (ev === 'pull_request') {
            const pr = context.payload.pull_request;
            const prNumber = String(pr?.number || '');
            const headSha = pr?.head?.sha || '';
            const headRef = pr?.head?.ref || '';
            const fullName = pr?.head?.repo?.full_name || '';
            const isFork = fullName !== `${context.repo.owner}/${context.repo.repo}`;

            const triggerKind = 'pr-sync';

            if (mode !== 'review') {
              return skip('mode-mismatch:want-review', { issue_number: prNumber, pr_number: prNumber, head_sha: headSha, head_ref: headRef, trigger_kind: triggerKind });
            }
            if (!headSha) return skip('no-head-sha', { issue_number: prNumber, pr_number: prNumber, trigger_kind: triggerKind });
            if (isFork) return skip('fork-pr-skip', { issue_number: prNumber, pr_number: prNumber, head_sha: headSha, head_ref: headRef, trigger_kind: triggerKind });

            // force-push-ish detection via compare (skip if status not normal)
            if (context.payload.action === 'synchronize') {
              const before = context.payload.before;
              const after = context.payload.after;
              if (before && after) {
                try {
                  const cmp = await github.rest.repos.compareCommits({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    base: before,
                    head: after,
                  });
                  const status = String(cmp.data?.status || '').toLowerCase();
                  const isNormal = (status === 'ahead' || status === 'identical');
                  if (!isNormal) {
                    return skip(`force-push:${status}`, { issue_number: prNumber, pr_number: prNumber, head_sha: headSha, head_ref: headRef, trigger_kind: triggerKind });
                  }
                } catch (e) {
                  return skip('force-push:compare-failed', { issue_number: prNumber, pr_number: prNumber, head_sha: headSha, head_ref: headRef, trigger_kind: triggerKind });
                }
              }
            }

            // head commit message prefix skip
            let headCommitMsg = '';
            try {
              const commitResp = await github.rest.repos.getCommit({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: headSha,
              });
              headCommitMsg = String(commitResp.data?.commit?.message || '');
              const msgLower = headCommitMsg.toLowerCase();
              if (skipPrefixes.some(p => msgLower.startsWith(p))) {
                return skip(`skip-commit-prefix:${msgLower.split('\n')[0]}`, { issue_number: prNumber, pr_number: prNumber, head_sha: headSha, head_ref: headRef, trigger_kind: triggerKind });
              }
            } catch (_) {}

            // implement running gate (optional exception for final sync)
            const implementing = await isImplementRunning({ prNumber, headRef, headSha });
            if (implementing) {
              const isSync = context.payload.action === 'synchronize';
              const senderType = String(context.payload.sender?.type || '');
              const markerOk = finalMarker && headCommitMsg && headCommitMsg.includes(finalMarker);
              const allow = allowFinalSync && isSync && (senderType === 'Bot' || markerOk);
              if (!allow) {
                return skip('implement-running', { issue_number: prNumber, pr_number: prNumber, head_sha: headSha, head_ref: headRef, trigger_kind: triggerKind });
              }
            }

            return ok({
              issue_number: prNumber,
              issue_url: pr?.html_url || '',
              pr_number: prNumber,
              head_sha: headSha,
              head_ref: headRef,
              comment_body: '',
              trigger_kind: triggerKind,
            });
          }

          // ---- issue_comment (implement/review by comment)
          if (ev !== 'issue_comment') {
            return skip(`unsupported-event:${ev}`);
          }

          const issue = context.payload.issue;
          const issueNumber = String(issue?.number || '');
          const issueUrl = String(issue?.html_url || '');
          const comment = context.payload.comment;
          const commentBody = String(comment?.body || '');
          const commentUserType = String(comment?.user?.type || '');

          if (!issueNumber) return skip('no-issue-number');

          // bot comment skip
          if (commentUserType.toLowerCase() === 'bot') {
            return skip('bot-comment', { issue_number: issueNumber, issue_url: issueUrl, comment_body: commentBody });
          }

          // normalize @ to avoid full-width, and lowercase
          const normalized = commentBody.replaceAll('＠', '@').toLowerCase();
          const hasClaude = normalized.includes('@claude');
          const hasReview = normalized.includes('[review]');

          if (!hasClaude) {
            return skip('no-@claude', { issue_number: issueNumber, issue_url: issueUrl, comment_body: commentBody });
          }

          // classify by comment
          let triggerKind = 'none';
          if (hasReview) {
            triggerKind = 'comment-review';
            if (mode !== 'review') return skip('mode-mismatch:want-review', { issue_number: issueNumber, issue_url: issueUrl, comment_body: commentBody, trigger_kind: triggerKind });
          } else {
            triggerKind = 'comment-implement';
            if (mode !== 'implement') return skip('mode-mismatch:want-implement', { issue_number: issueNumber, issue_url: issueUrl, comment_body: commentBody, trigger_kind: triggerKind });
          }

          // auth check for comment triggers
          const permResp = await github.rest.repos.getCollaboratorPermissionLevel({
            owner: context.repo.owner,
            repo: context.repo.repo,
            username: context.actor,
          });
          const perm = String(permResp.data?.permission || '').toLowerCase();
          if (!allowedPerms.has(perm)) {
            return skip(`unauthorized:${perm}`, { issue_number: issueNumber, issue_url: issueUrl, comment_body: commentBody, trigger_kind: triggerKind });
          }

          const isPrConversation = !!issue?.pull_request;

          // comment-review requires PR context
          if (mode === 'review' && !isPrConversation) {
            return skip('comment-review-on-issue-not-supported', { issue_number: issueNumber, issue_url: issueUrl, comment_body: commentBody, trigger_kind: triggerKind });
          }

          // PR conversation: resolve PR head ref/sha
          if (isPrConversation) {
            const prNumber = issueNumber;

            try {
              const prResp = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: Number(prNumber),
              });
              const pr = prResp.data;

              const headSha = pr.head?.sha || '';
              const headRef = pr.head?.ref || '';
              const fullName = pr.head?.repo?.full_name || '';
              const isFork = fullName !== `${context.repo.owner}/${context.repo.repo}`;
              if (isFork) {
                return skip('fork-pr-skip', { issue_number: issueNumber, issue_url: issueUrl, pr_number: prNumber, head_sha: headSha, head_ref: headRef, comment_body: commentBody, trigger_kind: triggerKind });
              }
              if (!headRef) {
                return skip('no-head-ref', { issue_number: issueNumber, issue_url: issueUrl, pr_number: prNumber, comment_body: commentBody, trigger_kind: triggerKind });
              }

              // If this is review-by-comment, also gate when implement running
              if (mode === 'review') {
                const implementing = await isImplementRunning({ prNumber, headRef, headSha });
                if (implementing) {
                  return skip('implement-running', { issue_number: issueNumber, issue_url: issueUrl, pr_number: prNumber, head_sha: headSha, head_ref: headRef, comment_body: commentBody, trigger_kind: triggerKind });
                }
              }

              return ok({
                issue_number: issueNumber,
                issue_url: issueUrl,
                pr_number: prNumber,
                head_sha: headSha,
                head_ref: headRef,
                comment_body: commentBody,
                trigger_kind: triggerKind,
              });
            } catch (e) {
              return skip(`failed-get-pr:${e.message}`, { issue_number: issueNumber, issue_url: issueUrl, pr_number: prNumber, comment_body: commentBody, trigger_kind: triggerKind });
            }
          }

          // Normal issue (not PR conversation)
          // A) Pre-create the exact branch name Claude will use, so compare won't 404.
          // Observed pattern: `${issue_branch_prefix}${issueNumber}-${YYYYMMDD-HHMM}` (UTC)
          // Use comment.created_at for stable timestamp.
          const createdAt = String(comment?.created_at || '');
          const ts = formatUtcYmdHm(createdAt || null);
          const branchName = `${issueBranchPrefix}${issueNumber}-${ts}`;

          // Claude's log compared against "master". We must create branch from that base (or at least ensure it exists).
          let baseSha = '';
          try {
            baseSha = await ensureBranchExistsFromBase({ branchName, baseBranch: compareBaseBranch });
          } catch (e) {
            return skip(String(e.message || e), { issue_number: issueNumber, issue_url: issueUrl, comment_body: commentBody, trigger_kind: triggerKind });
          }

          return ok({
            issue_number: issueNumber,
            issue_url: issueUrl,
            pr_number: '',
            head_sha: baseSha,     // base sha (useful for debug)
            head_ref: branchName,  // this prevents compare 404
            comment_body: commentBody,
            trigger_kind: triggerKind,
          });
